# 기본 예외처리
# 프로그램 실행 중 발생 가능한 문제들을 예상하여 대비하는 과정입니다.

# - 💀 에러 `Error` - 해결 불가능한 문제
    # - 회사에 가다가 총에 맞아/차에 치어 죽음
    #     - 회사에 죽어도 *(죽었으니까)*  못 감
    # - 무한루프, 메모리 한도 초과, 스택오버플로우 등…
    #     - 일반적으로 시스템 레벨의 문제

# - 🛑 예외 `Exception`  - 대비하여 해결할 수 있는 문제
#     - 가려던 출근길이 공사로 막힘, 지하철 운행 중단, 스텝이 꼬여 넘어짐
#         - 대책을 마련해두면 회사에 갈 수 있음
#     - 읽어오려는 파일이 없음, 배열의 길이 너머로 접근…

# 의도적으로 예외가 발생하는 코드 예

# print(1 / 0) #0으로 나눠서 예외

# my_list = [1, 2, 3]
# print(my_list[3]) # 범위 밖에 인덱스를 넣어뒀다

# print(not_defined_var) # 변수 이름을 작성하지 않음

# my_dict = {"a": 1, "b": 2}
# print(my_dict["c"])   #"c:" 딕셔너리가 없음

# "2" + 2  # 올바른 계산식이 아님

# with open("nonexistent_file.txt") as f:
#     content = f.read() #요청한 파일이 존재하지 않음



# 수동으로 오류 발생시키기
# raise 연산자 + 오류 객체
    # baseException 에서 파생된 클래스
    # warning 계열은 다르게 사용 (이휴 배울 warn 메소드)

# 클래스 자체로 발생
# raise Exception
# print("위 Exception 에서 멈춰서 프린트 안됨")

# 인스턴스를 만들어 발생
# 클래스의 생성자에 따라 메세지 등 입력
# raise ValueError("값 다시 입력해봐")
# print("역시 되지 않음")



